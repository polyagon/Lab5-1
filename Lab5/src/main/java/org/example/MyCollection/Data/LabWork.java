package org.example.MyCollection.Data;

import org.example.MyTools.Validators.AutoGenerated;
import org.example.MyTools.Validators.GreaterThen;
import org.example.MyTools.Validators.NotEmptyString;
import org.example.MyTools.Validators.NotNull;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Objects;
import java.util.UUID;
import java.util.function.Supplier;

public class LabWork extends Entity implements Comparable, Cloneable{

    @NotNull
    @AutoGenerated
    @GreaterThen("0")
    private long id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
    @NotNull
    @NotEmptyString
    private String name; //Поле не может быть null, Строка не может быть пустой
    @NotNull
    private Coordinates coordinates; //Поле не может быть null
    @AutoGenerated
    @NotNull
    private java.time.LocalDateTime creationDate; //Поле не может быть null, Значение этого поля должно генерироваться автоматически
    @GreaterThen("0")
    private Integer minimalPoint; //Поле может быть null, Значение поля должно быть больше 0
    private Difficulty difficulty; //Поле может быть null
    @NotNull
    private Person author; //Поле не может быть null



    public LabWork( String name, Coordinates coordinates, Integer minimalPoint, Difficulty difficulty, Person author){
        this.id = genereteID();
        creationDate = LocalDateTime.from(LocalDateTime.now());

            setName(name);
            setCoordinates(coordinates);
            setMinimalPoint(minimalPoint);
            setDifficulty(difficulty);
            setAuthor(author);
    }

    public LabWork(HashMap<String, Object> tree){
        init(tree);
    }

    public LabWork() {

    }


    public long getId() {
        return this.id;
    }
    public void setId(long id){
        this.id = id;
    }

    public long genereteID(){
        UUID uuid =  UUID.randomUUID();
        return Math.abs(uuid.getMostSignificantBits());
    }


    public String getName(){
        return this.name;
    }
    public void setName(String name){
        this.name = name;
    }


    public Coordinates getCoordinates(){
        return this.coordinates;
    }
    public void setCoordinates(Coordinates cor){
        this.coordinates = cor;
    }


    public java.time.LocalDateTime getCreationDate(){
        return creationDate;
    }
    public void setCreationDate(java.time.LocalDateTime date){
        this.creationDate = date;
    }


    public Integer getMinimalPoint(){
        return this.minimalPoint;
    }
    public void setMinimalPoint(Integer point){
        this.minimalPoint = point;
    }

    public Difficulty getDifficulty(){
        return this.difficulty;
    }
    public void setDifficulty(Difficulty difficulty){
        this.difficulty = difficulty;
    }

    public Person getAuthor(){
        return this.author;
    }
    public void setAuthor(Person person){
        this.author = person;
    }


    public String generateCSV() {
        String out = id +
                ", " + name +
                ", " + coordinates.generateCSV() +
                ", " + creationDate +
                ", " + minimalPoint+
                ", " + difficulty + ", ";
        if(author != null)  out+= author.generateCSV();
        else out += null;
        return out;

    }
    public static java.util.Date convertToDate(Object object) {
        if (object instanceof java.util.Date) {
            // Если объект уже является Date, возвращаем его
            return (java.util.Date) object;
        } else if (object instanceof String) {
            try {
                // Если объект - строка, пытаемся распарсить дату
                String dateString = (String) object;
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                return sdf.parse(dateString);
            } catch (Exception e) {
                System.out.println("Ошибка при парсинге строки в дату: " + e.getMessage());
            }
        } else if (object instanceof Long) {
            // Если объект - timestamp (долгое значение)
            return new java.util.Date((Long) object);
        }
        return null;  // Если тип объекта не поддерживается
    }


    @Override
    public LabWork clone() throws CloneNotSupportedException {
        return (LabWork) super.clone();
    }
    @Override
    public int hashCode() {
        return Objects.hash(id, name, coordinates, creationDate, minimalPoint, author,difficulty);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        LabWork check = (LabWork) o;
        return hashCode() == check.hashCode();
    }
    @Override
    public String toString(){
        String out = "LabWork(" +
                "\n\tid=" + id +
                "\n\tname=" + name +
                "\n\tcoordinates=" + coordinates.toString() +
                "\n\tcreationDate=" + creationDate.format(DateTimeFormatter.ofPattern("HH:mm:ss dd/MM/yyyy")) +
                "\n\tminimal point=" + minimalPoint +
                "\n\tdifficulty=" + difficulty +
                "\n\tauthor=" + author.toString();
        return  out + ");\n";
    }

    @Override
    public int compareTo(Object o) {
        if (o == null || getClass() != o.getClass()) return 0;
        if (((LabWork)o).id > this.id) return 1;
        else return -1;
    }



    @Override
    public void init(HashMap<String, Object> values) {
        if(values.containsKey("id")) this.id = (int) values.get("id");

        this.name = (String) values.get("name");
        this.coordinates = (Coordinates) values.get("coordinates");

        // if(values.containsKey("creationDate")) this.creationDate = LocalDateTime.ofEpochSecond(((Integer) values.get("creationDate")).longValue(), 0, ZoneOffset.UTC);
        if(!values.containsKey("creationDate")) this.creationDate = LocalDateTime.from(LocalDateTime.now());
        this.minimalPoint = (int) values.get("minimalPoint");
        if(values.containsKey("difficulty")) this.difficulty = (Difficulty) values.get("difficulty");
        if(values.containsKey("author")) this.author = (Person) values.get("author");

    }

    @Override
    public HashMap<String, Object> getValues() {
        HashMap<String, Object> values = new HashMap<>();
        values.put("id", id);
        values.put("name", name);
        values.put("coordinates", coordinates);
        values.put("creationDate", creationDate);
        values.put("minimalPoint", minimalPoint);
        values.put("difficulty", difficulty);
        values.put("author", author);
        return values;
    }

    public Supplier<Entity> getConstructorReference() {
        return LabWork::new;
    }
}
